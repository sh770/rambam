<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
  <meta charset="UTF-8" />
  <title>× ×™×ª×•×— × ×™×§×•×“ ×œ×¤×™ ×”×•×“×¢×•×ª ×•×•××˜×¡××¤</title>
  <style>
    body { font-family: Arial, sans-serif; margin: 2em; direction: rtl; }
    textarea { width: 100%; height: 200px; margin-top: 1em; }
    table { border-collapse: collapse; margin-top: 1em; width: 100%; }
    th, td { border: 1px solid #ccc; padding: 6px 8px; text-align: center; }
    h2 { margin-top: 2em; }
    .controls { margin-bottom: 1em; }
    button { margin-left: 0.5em; padding: 0.5em 1em; cursor: pointer; }
    input[type="date"], input[type="text"] { margin: 0.5em 0; padding: 0.4em; }
  </style>
</head>
<body>

  <h1>ğŸ“Š × ×™×ª×•×— × ×™×§×•×“ ×œ×¤×™ ×”×•×“×¢×•×ª ×•×•××˜×¡××¤</h1>

  <div class="controls">
    <label>
      ×¡× ×Ÿ ×”×•×“×¢×•×ª ×××•:
      <input type="date" id="filterDate" placeholder="dd.mm.yyyy" />
    </label>
    <br />
    <label>
      ××• ×”×—×œ ××¡×™×•× ×˜×§×¡×˜ ×–×”:
      <input type="text" id="filterText" placeholder="×›×ª×•×‘ ×›××Ÿ ××ª ×”×”×•×“×¢×” ×©××× ×” ×œ×”×ª×—×™×œ ×¡×¤×™×¨×”" />
    </label>
    <br />
    <label>××• ×”×¢×œ×” ×§×•×‘×¥ ×˜×§×¡×˜ (txt):</label>
    <input type="file" id="textFileInput" accept=".txt" />
    <br />
    <label>××• ×”×¢×œ×” ×§×•×‘×¥ ZIP ×¢× TXT:</label>
    <input type="file" id="zipFileInput" accept=".zip" />
  </div>

  <textarea id="textInput" placeholder="×”×“×‘×§ ×›××Ÿ ××ª ×™×™×¦×•× ×”×¦'××˜ ××• ×›×ª×•×‘ ×˜×§×¡×˜ ×™×“× ×™×ª..."></textarea>
  <br />

  <button id="analyzeBtn" disabled onclick="analyzeText()">× ×ª×—</button>
  <button onclick="clearAll()">× ×§×”</button>

  <div id="error" style="color:red; margin-top:1em;"></div>
  <div id="summary"></div>
  <div id="details"></div>

  <script>
    // ğŸ§  Utility: ××–×”×” ×›×œ ×¤×•×¨××˜ ×ª××¨×™×š ××¤×©×¨×™ ××•×•××˜×¡××¤
    function parseWhatsAppDate(line) {
      // Match examples: [1.11.2025, 21:05], 1.11.2025, 21:05 -, 1.11.25 21:05 -
      const regex = /(?:\[)?(\d{1,2})[./](\d{1,2})(?:[./](\d{2,4}))?,?\s*(\d{1,2}):(\d{2})/;
      const match = line.match(regex);
      if (!match) return null;

      const day = match[1].padStart(2, '0');
      const month = match[2].padStart(2, '0');
      let year = match[3];
      const hour = match[4].padStart(2, '0');
      const minute = match[5].padStart(2, '0');

      if (!year) {
        const now = new Date();
        year = now.getFullYear();
      } else if (year.length === 2) {
        year = '20' + year;
      }

      const iso = `${year}-${month}-${day}T${hour}:${minute}:00`;
      return new Date(iso);
    }

    // ğŸ§© × ×™×”×•×œ ×›×¤×ª×•×¨ ×”× ×™×ª×•×—
    const analyzeBtn = document.getElementById("analyzeBtn");
    const textInput = document.getElementById("textInput");
    const textFileInput = document.getElementById("textFileInput");
    const zipFileInput = document.getElementById("zipFileInput");

    [textInput, textFileInput, zipFileInput].forEach(el => {
      el.addEventListener("input", () => {
        analyzeBtn.disabled = false;
      });
      el.addEventListener("change", () => {
        analyzeBtn.disabled = false;
      });
    });

    // ğŸ§¹ × ×™×§×•×™ ××•×—×œ×˜
    function clearAll() {
      document.getElementById("textInput").value = "";
      document.getElementById("filterDate").value = "";
      document.getElementById("filterText").value = "";
      document.getElementById("error").innerText = "";
      document.getElementById("summary").innerHTML = "";
      document.getElementById("details").innerHTML = "";
      analyzeBtn.disabled = true;
    }

    // ğŸ“¥ ×§×¨×™××ª ×§×•×‘×¥ ×˜×§×¡×˜ ×¨×’×™×œ
    textFileInput.addEventListener("change", (e) => {
      const file = e.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = (ev) => {
        textInput.value = ev.target.result;
        analyzeBtn.disabled = false;
      };
      reader.readAsText(file);
    });

    // ğŸ“¦ ×§×¨×™××ª ×§×•×‘×¥ ZIP ×¢× TXT
    zipFileInput.addEventListener("change", async (e) => {
      const file = e.target.files[0];
      if (!file) return;
      const JSZip = await import("https://cdn.jsdelivr.net/npm/jszip@3.10.1/+esm");
      const data = await file.arrayBuffer();
      const zip = await JSZip.default.loadAsync(data);
      for (const fileName in zip.files) {
        if (fileName.endsWith(".txt")) {
          const txt = await zip.files[fileName].async("string");
          textInput.value = txt;
          analyzeBtn.disabled = false;
          break;
        }
      }
    });

    // ğŸ§® ×”×¤×•× ×§×¦×™×” ×”×¨××©×™×ª
    function analyzeText() {
      const errorEl = document.getElementById("error");
      const summaryEl = document.getElementById("summary");
      const detailsEl = document.getElementById("details");
      const filterDateValue = document.getElementById("filterDate").value;
      const filterTextValue = document.getElementById("filterText").value.trim();
      const rawText = textInput.value.trim();

      analyzeBtn.disabled = true; // ×× ×™×¢×ª × ×™×ª×•×— ×›×¤×•×œ

      if (!rawText) {
        errorEl.innerText = "×× × ×”×–×Ÿ ×˜×§×¡×˜ ×œ× ×™×ª×•×—.";
        return;
      }
      errorEl.innerText = "";

      // ×¤×™×¦×•×œ ×©×•×¨×•×ª
      const lines = rawText.split(/\r?\n/);
      const users = {};
      let filterDate = null;
      if (filterDateValue) filterDate = new Date(filterDateValue + "T00:00:00");

      let include = !filterTextValue && !filterDate; // ×× ××™×Ÿ ×¡×™× ×•×Ÿ, ×›×œ ×”×”×•×“×¢×•×ª × ×›×œ×œ×•×ª

      lines.forEach(line => {
        // ×“×™×œ×•×’ ×¢×œ ×”×•×“×¢×•×ª ××¢×¨×›×ª
        if (/<×”××“×™×” ×œ× × ×›×œ×œ×”>|×”×¦×˜×¨×£\/×” ×œ×§×‘×•×¦×”|×©×™× ×” ××ª ×©× ×”×§×‘×•×¦×”/.test(line)) return;

        const dateObj = parseWhatsAppDate(line);
        if (filterDate && dateObj && dateObj < filterDate) return; // ×“×™×œ×•×’ ×œ×¤× ×™ ×”×ª××¨×™×š

        if (!include && filterTextValue && line.includes(filterTextValue)) {
          include = true; // ××ª×—×™×œ×™× ×œ×›×œ×•×œ ××”×©×•×¨×” ×”×–××ª ×•×”×œ××”
          return; // ×œ× ×¡×•×¤×¨×™× ××ª ×”×©×•×¨×” ×©×œ ×¢×¦××”
        }

        if (!include) return; // ×¢×“×™×™×Ÿ ×œ×¤× ×™ ×”×¡×™× ×•×Ÿ

        const match = line.match(/(?:\] )?([^:]+):(.*)/);
        if (!match) return;

        const name = match[1].trim();
        const content = match[2].trim();

        const hasCheck = content.includes("âœ”ï¸");
        const hasV = content.includes("âœ…");
        const score = hasV ? 3 : hasCheck ? 2 : 1;

        if (!users[name]) users[name] = { score: 0, messages: 0, checkCount: 0, vCount: 0 };
        users[name].messages++;
        users[name].score += score;
        if (hasCheck) users[name].checkCount++;
        if (hasV) users[name].vCount++;
      });

      // ğŸ”¢ ×™×¦×™×¨×ª ×˜×‘×œ××•×ª
      const summaryRows = Object.entries(users)
        .map(([n, d]) => `<tr><td>${n}</td><td>${d.score}</td><td>${d.messages}</td></tr>`)
        .join("");
      summaryEl.innerHTML = `
        <h2>×˜×‘×œ×ª × ×™×§×•×“</h2>
        <table><thead><tr><th>×©×</th><th>× ×™×§×•×“</th><th>××¡×¤×¨ ×”×•×“×¢×•×ª</th></tr></thead><tbody>${summaryRows}</tbody></table>`;
      
      const detailsRows = Object.entries(users)
        .map(([n, d]) => `<tr><td>${n}</td><td>${d.messages}</td><td>${d.checkCount}</td><td>${d.vCount}</td></tr>`)
        .join("");
      detailsEl.innerHTML = `
        <h2>×¤×™×¨×•×˜ ×¡×™×× ×™×</h2>
        <table><thead><tr><th>×©×</th><th>××¡'</th><th>âœ”ï¸</th><th>âœ…</th></tr></thead><tbody>${detailsRows}</tbody></table>`;
    }
  </script>
</body>
</html>